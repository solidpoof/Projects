// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract HLAWReferral is Ownable, ReentrancyGuard {
    using Address for address;

    // Structs
    struct ReferralStats {
        uint256 refs;
        uint256 rewardsEarned;
        uint256 rewardsClaimed;
    }

    struct ReferralDetail {
        address user;
        uint256 depositAmount;
        uint256 rewardGenerated;
    }

    // Public Variables
    address public hlawExchange;
    IERC20 public hlawToken;

    // Mapping to store the referrer of each user
    mapping(address => address) private referrers;

    // Mapping to store the referral rewards for each user
    mapping(address => ReferralStats) public refStats;

    // Mapping to store detailed referral data for each referrer
    mapping(address => ReferralDetail[]) private referralDetails;

    bool private initialized;

    // Events
    event ReferralSet(address indexed user, address indexed referrer);
    event RewardAdded(address user, uint256 amount);
    event ReferralClaimed(address user, uint256 amount);

    constructor(address _hlawToken) Ownable(msg.sender) {
        hlawToken = IERC20(_hlawToken);
    }

    function init(address _hlawExchange) external onlyOwner {
        require(!initialized, "Can only initialize once!");
        require(_hlawExchange.code.length > 0, "Must be a contract address that is initialized.");
        hlawExchange = _hlawExchange;
        initialized = true;
    }

    function setReferral(address user, address referrer) external {
        require(msg.sender == hlawExchange, "Only the HLAW Exchange Contract can call setReferral.");
        if (referrer == user) {
            return;
        }
        if (referrers[user] == address(0)) {
            referrers[user] = referrer;
            refStats[referrer].refs += 1;
            referralDetails[referrer].push(
                ReferralDetail({
                    user: user,
                    depositAmount: 0,
                    rewardGenerated: 0
                })
            );
            emit ReferralSet(user, referrer);
        }
    }

    function getReferrer(address user) external view returns (address) {
        return referrers[user];
    }

    function addReward(address user, uint256 amount) external {
        require(
            msg.sender == hlawExchange,
            "Only the HLAW Exchange Contract can call addReward."
        );

        address referrer = referrers[user];
        if (referrer != address(0)) {
            refStats[referrer].rewardsEarned += amount;

            for (uint256 i = 0; i < referralDetails[referrer].length; i++) {
                if (referralDetails[referrer][i].user == user) {
                    referralDetails[referrer][i].rewardGenerated += amount;
                    break;
                }
            }

            emit RewardAdded(user, amount);
        }
    }

    function claimReward() external nonReentrant {
        require(
            refStats[msg.sender].rewardsEarned > 0,
            "You have no rewards to claim."
        );

        hlawToken.transfer(msg.sender, refStats[msg.sender].rewardsEarned);
        emit ReferralClaimed(msg.sender, refStats[msg.sender].rewardsEarned);

        refStats[msg.sender].rewardsClaimed += refStats[msg.sender]
            .rewardsEarned;
        refStats[msg.sender].rewardsEarned = 0;
    }

    /**
     * @dev Returns all the referred users and the rewards generated by them.
     * @param referrer The address of the referrer.
     * @return details Array of ReferralDetail structs containing user, depositAmount, and rewardGenerated.
     */
    function getReferralDetails(address referrer)
        external
        view
        returns (ReferralDetail[] memory details)
    {
        return referralDetails[referrer];
    }
}
