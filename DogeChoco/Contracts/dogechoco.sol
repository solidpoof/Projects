// SPDX-License-Identifier: MIT
pragma solidity =0.8.17;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./interfaces/IRouterV2.sol";
import "./interfaces/IFactoryV2.sol";
import "./interfaces/IPinkAntiBot.sol";

/**
 * @title DogeChoco
 * @notice Dogechoco is the first technological startup that recovers cocoa as a payment currency as in pre-Hispanic times and tokenizes the food of the future
 * with the Crypto Chocolates of mass consumption with a blockchain ecosystem to allocate part of the profits generated by the sales of real products to build
 * Ethereum validation and cryptocurrency mining facilities to repurchase and burn the native token on a permanent and recurring basis, introducing capital to
 * liquidity like no one had proposed before in history. It will also open franchises in the main tourist capitals where it can sell and consume its crypto chocolates.
 * The Chocoverse of the Metaverse is Dogechoco's proposal to revolutionize the global food trade by uniting artisans in decentralized lands with their factories,
 * museums, shops, permanent fairs and all the opportunities of the new parallel reality that the adorable puppy is creating. of the food community of the future
 * that will also participate in the GameFi and animation industry. Let's make history together in community with Dogechoco! Dogechoco Army!.
 */
contract DogeChoco is ERC20, ERC20Burnable, Ownable {
    //---------- Contracts ----------//
    IRouterV2 public ammRouter; // DEX router contract.
    IPinkAntiBot public pinkAntiBot; // Antibot contract.

    //---------- Variables ----------//
    address public lpPair; // Pair that contains the liquidity for the taxSwap.
    address payable public treasury; // Address that manages the funds for betting.
    uint256 public constant sellTax = 10; // 10% tax on sell.
    uint256 public constant txTax = 1; // 1% tax on transfer.
    bool public hasLiquidity; // Flag to check if you already have liquidity.
    bool public antiBotEnabled; // Flag to check if antibot feature is enabled.
    bool private onSwap; // Flag to check if on swap tax tokens.

    //---------- Storage -----------//
    mapping(address => bool) private _lpPairs; // Contains the liquidity pairs of the token.
    mapping(address => bool) private _isExcluded; // Contains the addresses excluded from the sell tax.

    //---------- Events -----------//
    event ModifiedExclusion(address account, bool enabled);
    event ModifiedPair(address pair, bool enabled);
    event NewTreasury(address newTreasury);
    event NewRouter(address newRouter, address lpPair);

    //---------- Constructor ----------//
    constructor(IRouterV2 _ammRouter, IPinkAntiBot _antibot)
        ERC20("DOGECHOCO", "DOGECHOCO")
    {
        _mint(msg.sender, 165_000_000 * 10**decimals());
        ammRouter = _ammRouter;
        pinkAntiBot = _antibot;
        lpPair = IFactoryV2(ammRouter.factory()).createPair(
            ammRouter.WETH(),
            address(this)
        );
        _lpPairs[lpPair] = true;
        _isExcluded[msg.sender] = true;
        _isExcluded[address(this)] = true;
        treasury = payable(msg.sender);
        hasLiquidity = false;
        pinkAntiBot.setTokenOwner(msg.sender);
        antiBotEnabled = true;
    }

    //---------- Modifiers ----------//
    /**
     * @dev Modify the status of the boolean onSwap for checks in the transfer.
     */
    modifier swapLocker() {
        onSwap = true;
        _;
        onSwap = false;
    }

    //----------- Internal Functions -----------//
    /**
     * @dev Swap the sell tax and send it to the treasury.
     * @param amount of tokens to swap.
     */
    function _taxSwap(uint256 amount) internal swapLocker {
        if (allowance(address(this), address(ammRouter)) != type(uint256).max) {
            _approve(address(this), address(ammRouter), type(uint256).max);
        }

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = ammRouter.WETH();

        try
            ammRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
                amount,
                0,
                path,
                treasury,
                block.timestamp
            )
        {} catch {
            return;
        }
    }

    /**
     * @dev Check if the pair has liquidity.
     */
    function _checkLiquidity() internal {
        require(!hasLiquidity, "Already have liquidity");
        if (balanceOf(lpPair) > 0) {
            hasLiquidity = true;
        }
    }

    /**
     * @dev Override the internal transfer function to apply the sell tax and distribute it.
     * @param sender address of origin.
     * @param recipient destination address.
     * @param amount tokens to transfer.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual override {
        require(
            sender != address(0x0),
            "ERC20: transfer from the zero address"
        );
        require(
            recipient != address(0x0),
            "ERC20: transfer to the zero address"
        );
        require(amount > 0, "Transfer amount must be greater than zero");

        if (antiBotEnabled) {
            pinkAntiBot.onPreTransferCheck(sender, recipient, amount);
        }

        if (!hasLiquidity) {
            _checkLiquidity();
        }

        if (!onSwap) {
            if (hasLiquidity) {
                uint256 balance = balanceOf(address(this));
                if (balance > 0) {
                    _taxSwap(balance);
                }
            }
        }

        // check whitelist
        bool excluded = _isExcluded[sender] || _isExcluded[recipient];
        bool buy = _lpPairs[sender];
        bool sell = _lpPairs[recipient];

        if (excluded) {
            super._transfer(sender, recipient, amount);
        } else {
            if (sell) {
                // sell tax amount
                uint256 taxAmount = (amount * sellTax) / 100;

                // tax transfer sent to this contract
                super._transfer(sender, address(this), taxAmount);
                // default transfer sent to recipient
                super._transfer(sender, recipient, amount - taxAmount);
            } else if (buy) {
                super._transfer(sender, recipient, amount);
            } else {
                // tx tax amount
                uint256 taxAmount = (amount * txTax) / 100;
                // burn tx tax
                _burn(sender, taxAmount);
                // default transfer sent to recipient
                super._transfer(sender, recipient, amount - taxAmount);
            }
        }
    }

    //----------- External Functions -----------//
    /**
     * @notice Forward the ETH to the treasury address.
     */
    receive() external payable {
        uint256 amount = msg.value;
        (bool success, ) = treasury.call{value: amount, gas: 35000}("");
        require(success);
    }

    /**
     * @notice Check if a address is excluded from tax.
     * @param account address to check.
     * @return Boolean if excluded or not.
     */
    function isExcluded(address account) external view returns (bool) {
        return _isExcluded[account];
    }

    /**
     * @notice Check if a pair address is on list.
     * @param pair address to check.
     * @return Boolean if on list or not.
     */
    function isLpPair(address pair) external view returns (bool) {
        return _lpPairs[pair];
    }

    //----------- Owner Functions -----------//
    /**
     * @notice Set address in exclude list.
     * @param account address to set.
     * @param enabled boolean to enable or disable.
     */
    function setExcluded(address account, bool enabled) external onlyOwner {
        require(account != address(0x0), "Invalid address");
        _isExcluded[account] = enabled;
        emit ModifiedExclusion(account, enabled);
    }

    /**
     * @notice Set address in pairs list.
     * @param pair address to set.
     * @param enabled boolean to enable or disable.
     */
    function setLpPair(address pair, bool enabled) external onlyOwner {
        require(pair != address(0x0), "Invalid pair");
        _lpPairs[pair] = enabled;
        emit ModifiedPair(pair, enabled);
    }

    /**
     * @notice Change the trasury address.
     * @param newTreasury address to set.
     */
    function setTreasury(address newTreasury) external onlyOwner {
        require(newTreasury != address(0x0), "Invalid address");
        treasury = payable(newTreasury);
        emit NewTreasury(newTreasury);
    }

    /**
     * @notice Enable or disabled antibot feature.
     * @param enable boolean to enable or disable.
     */
    function setEnableAntiBot(bool enable) external onlyOwner {
        antiBotEnabled = enable;
    }

    /**
     * @notice Change the dex router address before having liquidity.
     * @param newRouter address to set.
     */
    function setAMMRouter(address newRouter) external onlyOwner {
        require(newRouter != address(0x0), "Invalid router");
        require(!hasLiquidity, "Already have liquidity");
        IRouterV2 router = IRouterV2(newRouter);
        address newPair = IFactoryV2(router.factory()).getPair(
            address(this),
            router.WETH()
        );
        if (newPair == address(0x0)) {
            lpPair = IFactoryV2(router.factory()).createPair(
                address(this),
                router.WETH()
            );
        } else {
            lpPair = newPair;
        }
        ammRouter = router;
        _approve(address(this), address(ammRouter), type(uint256).max);
        emit NewRouter(newRouter, lpPair);
    }

    /**
     * @notice Burn tokens of sell tax.
     * @param amount to burn.
     */
    function burnTax(uint256 amount) external onlyOwner {
        uint256 balance = balanceOf(address(this));
        require(amount > 0 && balance > 0, "Zero amount");
        uint256 toBurn = amount > balance ? balance : amount;
        _burn(address(this), toBurn);
    }

    /**
     * @notice Swap tokens of sell tax.
     * @param amount to swap.
     */
    function swapTax(uint256 amount) external onlyOwner {
        uint256 balance = balanceOf(address(this));
        require(amount > 0 && balance > 0, "Zero amount");
        uint256 toSwap = amount > balance ? balance : amount;
        _taxSwap(toSwap);
    }
}